//===========================================================================
//SOFTWARE:     3D geometric model for CNT and GNP networks
//OBJECTIVE:    Calculate electrical resistivity of a network read from an Abaqus output file (.odb)
//AUTHOR:       Angel Mora
//E-MAIL:       angel.mora@cicy.mx
//===========================================================================

#include "App_Network_From_Abaqus.h"

//Generate 3D nanoparticle network, turn it into a resitor network and find its electrical conductivity
int App_Network_From_Abaqus::Nanoparticle_resistor_network_from_odb(Input* Init)const
{
    //Time markers for total simulation
    time_t ct0, ct1;

    //Variables for CNTs
    //CNTs points
    vector<Point_3D> points_cnt;
    //CNTs radii
    vector<double> radii;
    //CNT structure, each cnts_structure[i] referes to the points in CNT_i
    vector<vector<long int> > structure_cnt;

    //Variables for GNPs
    //GNPs
    vector<GNP> gnps;
    //GNP points (only those needed are stored)
    vector<Point_3D> points_gnp;
    //GNP structure, each structure_gnp[i] referes to the points in GNP_i
    vector<vector<long int> > structure_gnp;

    //Shell vectors (used to remove nanoparticles when reducing observation window size)
    vector<vector<int> > shells_cnts;

    //Initialize Abaqus C++ API
    odb_initializeAPI();

    //Open Abaqus database using the name/path intidated in the input file
    //Use a C string, since that seems to be equivalent to (or able to be cast as) an odb_String
    odb_Odb& odb = openOdb(Init->simu_para.odb_file.c_str());

    //Get all frames from the steps and save them in a (pointer) variable
    odb_SequenceFrame& allFramesInStep = odb.steps()[Init->simu_para.step_name.c_str()].frames();
    //Get the number of frames in the database
    int n_frames = allFramesInStep.size();
    cout << "There are " << n_frames << " fames in the Abaqus database" << endl;

    //----------------------------------------------------------------------
    //Read CNTs and GNPs from csv file (generated by Generate_Network) and 
    //fill the CNT and GNP variables
    //Also read the sample geometry
    if (!Generate_nanoparticle_network_from_file(Init->simu_para, Init->vis_flags, Init->geom_sample, points_cnt, radii, structure_cnt, gnps))
    {
        hout << "Error when generating a nanoparticle network from a file" << endl;
        return 0;
    }

    //----------------------------------------------------------------------
    //Vector for GNP shells
    vector<Shell> shell_gnps(gnps.size());
    ct0 = time(NULL);
    Shells* SH = new Shells;
    if (!SH->Generate_shells(Init->simu_para.particle_type, Init->geom_sample, points_cnt, gnps, shells_cnts, shell_gnps)) {
        hout << "Error when generating shells" << endl;
        return 0;
    }
    delete SH;
    ct1 = time(NULL);
    hout << "Generate shells and structure time: " << (int)(ct1 - ct0) << " secs." << endl;

    //Iterate over the number of frames
    for (int i = 0; i < n_frames; i++)
    {
        hout << "============================================================================" << endl;
        hout << "============================================================================" << endl;
        hout << "Frame " << i << endl;
        time_t it0, it1;
        it0 = time(NULL);

        //Update observation window geometry (from current frame)
        cuboid window_geo;
        //hout<<"window_geo = "<<window_geo.str()<<endl;

        //Export the window geometry if needed
        if (Init->vis_flags.window_domain) {
            string str = "window_" + to_string(i) + ".vtk";
            VTK_Export VTK_E;
            VTK_E.Export_cuboid(window_geo, str);
        }

        //----------------------------------------------------------------------
        //Apply displacement to CNTs and GNPs, except for frame 0
        if (i)
        {
            //
        }

        //----------------------------------------------------------------------
        //Determine the local networks in cutoff windows
        Cutoff_Wins* Cutwins = new Cutoff_Wins;
        //From this function I get the internal variables cnts_inside and boundary_cnt
        ct0 = time(NULL);
        //hout<<"Extract_observation_window"<<endl;
        if (!Cutwins->Extract_observation_window(i, Init->simu_para.particle_type, Init->geom_sample, window_geo, Init->nanotube_geo, gnps, structure_cnt, radii, points_cnt, shells_cnts, shell_gnps, structure_gnp, points_gnp)) {
            hout << "Error when extracting observation window " << i + 1 << endl;
            return 0;
        }
        ct1 = time(NULL);
        hout << "Extract observation window time: " << (int)(ct1 - ct0) << " secs." << endl;

        //----------------------------------------------------------------------
        //Determine the local networks inside the cutoff windows
        Contact_grid* Contacts = new Contact_grid;
        ct0 = time(NULL);
        if (!Contacts->Generate_contact_grid(i, Init->simu_para.particle_type, Init->geom_sample, window_geo, Cutwins->cnts_inside, points_cnt, structure_cnt, Cutwins->gnps_inside, gnps)) {
            hout << "Error when generating contact grid" << endl;
            return 0;
        }
        ct1 = time(NULL);
        hout << "Generate contact grid time: " << (int)(ct1 - ct0) << " secs." << endl;

        //----------------------------------------------------------------------
        //Hoshen-Kopelman algorithm
        Hoshen_Kopelman* HoKo = new Hoshen_Kopelman;
        ct0 = time(NULL);
        if (!HoKo->Determine_clusters_and_percolation(i, Init->simu_para, Init->cutoff_dist, Init->vis_flags, Cutwins->cnts_inside, Contacts->sectioned_domain_cnts, structure_cnt, points_cnt, radii, Cutwins->boundary_cnt, Cutwins->gnps_inside, Contacts->sectioned_domain_gnps, gnps, Cutwins->boundary_gnp, structure_gnp, points_gnp)) {
            hout << "Error when finding clusters and determining percolation" << endl;
            return 0;
        }
        ct1 = time(NULL);
        hout << "Find clusters and determine percolation: " << (int)(ct1 - ct0) << " secs." << endl;

        //Contacts are not needed anymore, so delete the object
        delete Contacts;

        //Loop over the different clusters so that the direct electrifying algorithm is aplied on each cluster
        Electrical_analysis* EA = new Electrical_analysis;
        if (!EA->Perform_analysis_on_clusters(i, window_geo, Init->simu_para, Init->electric_para, Init->cutoff_dist, Init->vis_flags, Init->out_flags, HoKo, Cutwins, structure_cnt, points_cnt, radii, points_gnp, structure_gnp, gnps)) {
            hout << "Error when performing electrical analysis" << endl;
            return 0;
        }

        //Delete objects to free memory
        delete EA;
        delete Cutwins;
        delete HoKo;

        it1 = time(NULL);
        hout << "Iteration " << i + 1 << " time: " << (int)(it1 - it0) << " secs." << endl;
    }

    //Close Abaqus database
    odb.close();

    //Finalize usage of Abaqus C++ API
    odb_finalizeAPI();

    return 1;
}
//This function reads the data from a csv file to generate a nanoparticle network
int App_Network_From_Abaqus::Generate_nanoparticle_network_from_file(const Simu_para& simu_para, const Visualization_flags& vis_flags, Geom_sample& geom_sample, vector<Point_3D>& points_cnt, vector<double>& radii, vector<vector<long int> >& structure, vector<GNP>& gnps)const
{
    //Read sample geometry
    if (!Read_sample_geometry(geom_sample))
    {
        hout << "Error in Generate_nanoparticle_network_from_file when reading the sample geometry from file" << endl;
        return 0;
    }

    //Check the type of nanoparticle 
    if (simu_para.particle_type == "CNT_wires" || simu_para.particle_type == "CNT_deposit" || simu_para.particle_type == "GNP_CNT_mix") {

        //Read the structure and CNT points
        if (!Read_cnt_data_from_csv(points_cnt, radii, structure))
        {
            hout << "Error in Generate_nanoparticle_network_from_file when calling Read_cnt_data_from_csv." << endl;
            return 0;

        }
    }
    else if (simu_para.particle_type == "GNP_cuboids" || simu_para.particle_type == "GNP_CNT_mix") {

        //Read the GNP geometry
        if (!Read_gnp_data_from_csv(geom_sample.sample, gnps))
        {
            hout << "Error in Generate_nanoparticle_network_from_file when calling Read_gnp_data_from_csv." << endl;
            return 0;
        }
    }
    else if (simu_para.particle_type == "Hybrid_particles") {
        hout << "Hybrid particles not yet implemented" << endl;
        return 0;
    }
    else {
        hout << "Error in Generate_nanoparticle_network_from_file: the type of particles shoud be one of the following: CNT_wires, CNT_deposit, GNP_cuboids, Hybrid_particles or GNP_CNT_mix. Input value was: " << simu_para.particle_type << endl;
        return 0;
    }

    //---------------------------------------------------------------------------
    //Check if visualization files were requested for read nanoparticles
    if (vis_flags.generated_nanoparticles) {

        VTK_Export vtk_exp;

        //Export generated CNTs if any
        if (points_cnt.size()) {
            vtk_exp.Export_from_cnt_structure(points_cnt, structure, "cnts_read.vtk");
        }

        //Export generated GNPs if any
        if (gnps.size()) {
            vtk_exp.Export_gnps(gnps, "gnps_read.vtk");
        }

        //Export the sample geometry
        vtk_exp.Export_cuboid(geom_sample.sample, "sample.vtk");
    }

    return 1;
}
//This function reads the CNT data from csv files (cnt_struct.csv and cnt_coordinates.csv) 
int App_Network_From_Abaqus::Read_cnt_data_from_csv(vector<Point_3D>& points_cnt, vector<double>& radii, vector<vector<long int> >& structure)const
{
    //Open the structure file
    ifstream struc_file;
    struc_file.open("cnt_struct.csv");
    if (!struc_file) { 
        hout << "Failed to open CNT structure file cnt_struct.csv." << endl;  
        return 0; 
    }

    //Integers to store the number of CNTs
    int n_cnts, n_cnts_check;

    //Read the first line of the structure file, which has the number of CNTs
    struc_file >> n_cnts >> n_cnts_check;

    //Check that both numbers in the first line of the structure file are the same
    if (n_cnts != n_cnts_check) {
        hout << "Error in Read_cnt_data_from_csv. The first line of file cnt_struct.csv indicates different number of CNTs: " << n_cnts << " and " << n_cnts_check << endl;
        return 0;
    }

    //Set the size of the structure vector to store the indicated number of CNTs
    structure.assign(n_cnts, vector<long int>());

    //Set the size of the redius vector
    radii.assign(n_cnts, 0.0);

    //Variable to store the total number of CNT points in the network
    long int Np = 0;

    //String to read lines from file
    string line;

    //Read the structure
    for (int i = 0; i < n_cnts; i++)
    {
        //Check if end-of-file has been reached
        if (struc_file.eof())
        {
            hout << "Error in Read_cnt_data_from_csv. The end-of-file of cnt_struct.csv has been reached before reading all CNT data." << endl;
            return 0;
        }

        //Variable to store the number of points in CNT i
        int np;

        //Read a line form the file and store it in a string stream
        getline(struc_file, line);
        stringstream ss(line);

        //Read the number of CNT points from the string stream
        ss >> np;
        //Ignore the comma in the line
        ss.ignore();

        //Read the radius from the string stream
        ss >> radii[i];

        //Fill structure vector for CNT i
        structure[i].assign(np, Np);
        //index i = 0 is ignored since that is the value with which 
        //structure[i] is initialized
        for (int j = 1; j < np; j++)
        {
            //Set the j-th point in CNT i
            structure[i][j] = Np;

            //Increase the count for the number of CNT points
            Np++;
        }
    }

    //Open the point coordinates file
    ifstream  coord_file;
    coord_file.open("cnt_coordinates.csv");
    if (!coord_file) {
        hout << "Failed to open point cordinates file cnt_coordinates.csv." << endl;
        return 0;
    }

    //Set the size for the points vector
    points_cnt.assign(Np, Point_3D());

    //Read the point coordinates
    for (long int i = 0; i < Np; i++)
    {
        //Check if end-of-file has been reached
        if (coord_file.eof())
        {
            hout << "Error in Read_cnt_data_from_csv. The end-of-file of cnt_coordinates.csv has been reached before reading all CNT data." << endl;
            return 0;
        }

        //Read a line form the file and store it in a string stream
        getline(coord_file, line);
        stringstream ss(line);

        //Read the point coordinates from the string stream while ignoring the commas in between
        ss >> points_cnt[i].x;
        ss.ignore();
        ss >> points_cnt[i].y;
        ss.ignore();
        ss >> points_cnt[i].z;
        
    }

    //Close files
    struc_file.close();
    coord_file.close();

    return 1;
}
//This function reads GNP data from a csv file (gnp_data.csv)
int App_Network_From_Abaqus::Read_gnp_data_from_csv(const cuboid& sample_geom, vector<GNP>& gnps)const
{
    //Open the file with the GNP geometric data
    ifstream gnp_file;
    gnp_file.open("gnp_data.csv");
    if (!gnp_file) {
        hout << "Failed to open file with GNP geometric data gnp_data.csv." << endl;
        return 0;
    }

    //Generate_Network object to generate the variables needed for each GNP
    Generate_Network GN;

    //String to read lines from file
    string line;

    //Read the file
    while (getline(gnp_file, line))
    {
        //Read a line from the file and it in a string stream
        getline(gnp_file, line);
        stringstream ss(line);

        //GNP to store the values read from the file
        GNP new_gnp;

        //Variables to store the angles
        double theta, phi;

        //Read the values while ignoring the commas
        ss >> new_gnp.l;
        //Ignore the next entry as it is the same as l_GNP (also ignore two commas)
        ss.ignore(); ss.ignore(); ss.ignore();
        ss >> new_gnp.t; ss.ignore();
        ss >> theta; ss.ignore();
        ss >> phi; ss.ignore();
        ss >> new_gnp.center.x; ss.ignore();
        ss >> new_gnp.center.y; ss.ignore();
        ss >> new_gnp.center.z; 

        //Calculate rotation matrix
        new_gnp.rotation = GN.Get_transformation_matrix(theta, phi);

        //Calculate (or approximate) GNP volume
        int i;
        for (i = 0; i < 8; i++)
        {
            if (!GN.Is_point_inside_cuboid(sample_geom, new_gnp.vertices[i])) {

                //GNP is partially outside the sample, so approximate volume
                double gnp_vol = 0.0;
                if (!GN.Approximate_gnp_volume_inside_sample(sample_geom, new_gnp, gnp_vol)) {
                    hout << "Error in Read_gnp_data_from_csv when calling Approximate_gnp_volume_inside_sample." << endl;
                    return 0;
                }
                new_gnp.volume = gnp_vol;

                //Terminate the for loop
                break;
            }
        }

        //Check if all vertices were inside the sample
        if (i == 7)
        {
            //All vertices were inside the sample, thus calcualte the volume of the whole GNP
            new_gnp.volume = new_gnp.l * new_gnp.l * new_gnp.t;
        }

        //Obtain coordinates of GNP vertices
        if (!GN.Obtain_gnp_vertex_coordinates(new_gnp)) {
            hout << "Error in Read_gnp_data_from_csv when calling Obtain_gnp_vertex_coordinates." << endl;
            return 0;
        }

        //Get the plane equations for the six faces
        if (!GN.Update_gnp_plane_equations(new_gnp)) {
            hout << "Error in Read_gnp_data_from_csv when calling Update_gnp_plane_equations." << endl;
            return 0;
        }

        //Add GNP to the vector of GNPs
        gnps.push_back(new_gnp);
    }

    //Close file
    gnp_file.close();

    return 1;
}
//This function reads the sample geomtry from a csv file (sample_geom.csv)
int App_Network_From_Abaqus::Read_sample_geometry(Geom_sample& geom_sample)const
{
    //Open the file with the sample geometry data
    ifstream sample_file;
    sample_file.open("sample_geom.csv");
    if (!sample_file) {
        hout << "Failed to open file with sample geometry data sample_geom.csv." << endl;
        return 0;
    }

    //String to read lines from file
    string line;

    //Read the first line form the file and store it in a string stream
    getline(sample_file, line);
    stringstream ss_point(line);

    //Read the lower left corner of the sample while ignoring the commas in between
    ss_point >> geom_sample.sample.poi_min.x;
    ss_point.ignore();
    ss_point >> geom_sample.sample.poi_min.y;
    ss_point.ignore();
    ss_point >> geom_sample.sample.poi_min.z;

    //Read the second line form the file and store it in a string stream
    getline(sample_file, line);
    stringstream ss_size(line);

    //Read the dimensions of the sample along each direction while ignoring the commas in between
    ss_size >> geom_sample.sample.len_x;
    ss_size.ignore();
    ss_size >> geom_sample.sample.wid_y;
    ss_size.ignore();
    ss_size >> geom_sample.sample.hei_z;

    //Calculate the sample's volume
    geom_sample.volume = geom_sample.sample.len_x * geom_sample.sample.wid_y * geom_sample.sample.hei_z;

    //Calculate the coordinates of the sample's boundaries opposite to those given by the coordinates of origin
    geom_sample.sample.max_x = geom_sample.sample.poi_min.x + geom_sample.sample.len_x;
    geom_sample.sample.max_y = geom_sample.sample.poi_min.y + geom_sample.sample.wid_y;
    geom_sample.sample.max_z = geom_sample.sample.poi_min.z + geom_sample.sample.hei_z;

    //Close file
    sample_file.close();

    return 1;
}
//===========================================================================
